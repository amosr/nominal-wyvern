type Eq { z =>
  type E >= Bot
}

type List { z =>
  type T <= Unit
  type E = List {type T <= Eq {type E >= z.T}}
}
subtype List extends Eq
// OK

type Tree {z =>
  type T <= Tree
  type E = List {type T <= Eq {type E >= z.T}}
}
subtype Tree {} extends List
// OK

val bad : List { type T <= Eq { type E >= Tree } } = new Tree { this =>
  type T = Tree
  type E = List {type T <= Eq {type E >= this.T}}
}
/*
* no typing derivation in thesis rules
* no cycles in subtyping dependency graph in thesis rules
* typechecking diverges in master
* typechecking fails in more recent branches


(declared subtyping)       (stuck)
----------------           ---------------------------------------------------  (SR-CONS)
List -({})> Tree           {} <: { type T <= Eq { type E >= Tree } }
------------------------------------------------------------------------------- (S-NAME)
Tree {} <: List { type T <= Eq { type E >= Tree } }


Tree <: List

Tree <: List { type T <= Unit }

Tree <: Tree { type T = Tree } <: List

*/


0
