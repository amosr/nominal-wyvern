type Monoid:z {
  type T <= Unit
  val id : z.T
  def op(a:z.T, b:z.T):z.T
}

type List:z {
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
}

type Nil:z {
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
}
subtype Nil extends List

type Cons:z {
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
  val head:z.T
  val tail:List {type T >= z.T}
}

type Param:z {
  type A <= Unit
}
type AA:z {
  def makeNil(a:Param):List {type T = a.A}
  def makeCons(a:Param, x:a.A, xs:List {type T = a.A}):List {type T = a.A}
}

val aa = new this:AA {
  def makeNil(a:Param):List {type T = a.A} {
    type T = a.A
    new z:Nil {type T = a.A} {
      def foldr(m:Monoid {type T >= z.T}):m.T {
        m.id
      }
    }
  }
  def makeCons(a:Param, x:a.A, xs:List {type T = a.A}):List {type T = a.A} {
    new z:Cons {type T = a.A} {
      type T = a.A
      def foldr(m:Monoid {type T >= z.T}):m.T {
        val tailVal = z.tail.foldr(m)
        val ret = m.op(z.head,tailVal)
        ret
      }
      val head = x
      val tail = xs
    }
  }
}

val UnitP = new this:Param {type A = Unit} {
  type A = Unit
}
val UnitM = new z:Monoid {type T = Unit} {
  type T = Unit
  val id = Unit
  def op(a:z.T, b:z.T):z.T {
    a
  }
}

val unit = Unit
val unitNil = aa.makeNil(UnitP)
val l1 = aa.makeCons(UnitP,unit,unitNil)
l1.foldr(UnitM)
