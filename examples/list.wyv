type Monoid {z =>
  type T <= Unit
  val id : z.T
  def op(a:z.T, b:z.T):z.T
}

type List {z =>
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
}

type Nil {z =>
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
}
subtype Nil extends List

type Cons {z =>
  type T <= Unit
  def foldr(m:Monoid {type T >= z.T}):m.T
  val head:z.T
  val tail:List {type T >= z.T}
}

type Param {z =>
  type A <= Unit
}
type AA {z =>
  def makeNil(a:Param):List {type T = a.A}
  def makeCons(a:Param, x:a.A, xs:List {type T = a.A}):Cons {type T = a.A}
}

Unit
/*
val aa = new AA {this =>
  def makeNil(a:Param):List {type T = a.A} {
    new Nil {type T = a.A} {z =>
      type T = a.A
      def foldr(m:Monoid {type T >= z.T}):m.T {
        m.id
      }
    }
  }
  def makeCons(a:Param, x:a.A, xs:List {type T = a.A}):Cons {type T = a.A} {
    new Cons {type T = a.A} {z =>
      type T = a.A
      def foldr(m:Monoid {type T >= z.T}):m.T {
        val tailVal = z.tail.foldr(m)
        val ret = m.op(z.head,tailVal)
        ret
      }
      val head = x
      val tail = xs
    }
  }
}

val UnitP = new Param {type A = Unit} {this =>
  type A = Unit
}
val UnitM = new Monoid {type T = Unit} {z =>
  type T = Unit
  val id = Unit
  def op(a:z.T, b:z.T):z.T {
    a
  }
}

val unit = Unit
val unitNil = aa.makeNil(UnitP)
val l1 = aa.makeCons(UnitP,unit,unitNil)
//l1.foldr(UnitM)
l1.tail
*/
